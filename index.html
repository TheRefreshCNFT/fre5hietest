<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; overflow: hidden; background-color: black; }
    canvas { display: block; touch-action: none; }
  </style>
</head>
<body>
<canvas id="patternCanvas"></canvas>
<script>
  const canvas = document.getElementById("patternCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;


  // Global variables
  const textColors = ["#f48e00", "#29eb3c", "#f7ea36", "#4bd9f2", "#f70057"]; // Array of colors for the text gradient
  let currentTextColorIndex = 0; // Track the current color for the text
  let blinkTimer = 0; // Counter to control the blinking effect
  const numShapes = 19; // Number of mandala shapes
  const maxDriftWidth = 50; // Maximum horizontal drift width
  const shapes = []; // Array to store shape objects
  let time = 0;
  let letterColorIndices = {};
  // Initialize shapes with properties
  function initializeShapes() {
    shapes.length = 0;
    const maxRadius = Math.min(canvas.width, canvas.height) / 3;
    const minDistance = 100; // Minimum distance between flakes

    for (let i = 0; i < numShapes; i++) {
      let radius, x, y, validPosition;
      let attempts = 0;

      do {
        validPosition = true; // Assume the position is valid initially
        radius = Math.random() * maxRadius * 0.4 + maxRadius * 0.075;
        x = Math.random() * canvas.width;
        y = Math.random() * canvas.height;

        // Check against all previously placed shapes
        for (const existingShape of shapes) {
          const distance = Math.hypot(x - existingShape.x, y - existingShape.y);
          if (distance < minDistance) {
            validPosition = false; // Too close to an existing shape
            break;
          }
        }

        attempts++;
        if (attempts > 100) break; // Avoid infinite loops in dense configurations

      } while (!validPosition);

      // Add the new shape if a valid position was found
      if (validPosition) {
        shapes.push({
          x: x,
          y: y,
          radius: radius,
          symmetry: Math.floor(Math.random() * 8 + 6),
          lineDensity: Math.floor(Math.random() * 30 + 20),
          phaseShift: Math.random() * Math.PI * 2,
          driftAmplitude: Math.random() * maxDriftWidth,
          verticalSpeed: Math.random() * 1.5 + 0.5,
          oscillationSpeed: Math.random() * 0.01 + 0.002,
          driftOffset: Math.random() * Math.PI * 2,
          color1: colors[Math.floor(Math.random() * colors.length)],
          color2: colors[Math.floor(Math.random() * colors.length)],
          colorTransitionSpeed: Math.random() * 0.07 + 0.05,
        });
      }
    }
  }

  const colors = [
    "#edbf0b",
    "#a42820", // Red
    "#f7382e", // Orange
    "#0a7131", // Green
    "#0caa48"
  ];

  function interpolateHexColor(color1, color2, factor) {
    const hexToRgb = hex => [
      parseInt(hex.slice(1, 3), 16),
      parseInt(hex.slice(3, 5), 16),
      parseInt(hex.slice(5, 7), 16)
    ];

    const rgbToHex = ([r, g, b]) =>
      `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b
        .toString(16)
        .padStart(2, "0")}`;

    const rgb1 = hexToRgb(color1);
    const rgb2 = hexToRgb(color2);

    const interpolatedRgb = rgb1.map((value, index) =>
      Math.round(value + factor * (rgb2[index] - value))
    );

    return rgbToHex(interpolatedRgb);
  }


  function updateShapes() {
    for (let shape of shapes) {
      // Subtle downward movement
      shape.y += shape.verticalSpeed;

      // Gentle horizontal swaying
      shape.x += Math.sin(time * shape.oscillationSpeed + shape.driftOffset) * (shape.driftAmplitude / 100);

      // Edge detection: Prevent flakes from leaving the canvas horizontally
      if (shape.x - shape.radius < 0) {
        shape.x = shape.radius; // Snap to the left edge
      }
      if (shape.x + shape.radius > canvas.width) {
        shape.x = canvas.width - shape.radius; // Snap to the right edge
      }

      // Reset position when shape goes off the bottom of the screen
      if (shape.y - shape.radius > canvas.height) {
        shape.y = -shape.radius; // Re-enter from top
        shape.x = Math.random() * canvas.width; // Randomize horizontal position
      }

      shape.phaseShift += 0.002;
    }
  }


  function drawMandala(shape) {
    const { x, y, radius, symmetry, lineDensity, phaseShift, color1, color2, colorTransitionSpeed } = shape;

    ctx.save();
    ctx.translate(x, y);

    for (let i = 0; i < symmetry; i++) {
      const angle = (i / symmetry) * Math.PI * 2 + phaseShift;
      ctx.save();
      ctx.rotate(angle);

      for (let j = 0; j < lineDensity; j++) {
        const offset = (j / lineDensity) * radius;

        // Interpolate colors dynamically for animation
        const factor = (Math.sin(time * colorTransitionSpeed + j * 0.1) + 1) / 2; // Smooth oscillation
        const interpolatedColor = interpolateHexColor(color1, color2, factor);

        const dynamicGradient = ctx.createLinearGradient(-offset, 0, offset, 0);
        dynamicGradient.addColorStop(0, interpolatedColor);
        dynamicGradient.addColorStop(1, "rgba(0, 0, 0, 1)");

        ctx.strokeStyle = dynamicGradient;
        ctx.lineWidth = 1;

        ctx.beginPath();
        ctx.moveTo(0, offset);
        ctx.lineTo(offset, 0);
        ctx.strokeStyle = "#ffffff";
        ctx.stroke();
      }

      ctx.restore();
    }

    ctx.restore();
  }

  function updateShapes() {
    for (let shape of shapes) {
      // Subtle downward movement
      shape.y += shape.verticalSpeed;

      // Gentle horizontal swaying
      shape.x += Math.sin(time * shape.oscillationSpeed + shape.driftOffset) * (shape.driftAmplitude / 100);

      // Reset position when shape goes off the bottom of the screen
      if (shape.y - shape.radius > canvas.height) {
        shape.y = -shape.radius;
        shape.x = Math.random() * canvas.width;
      }

      shape.phaseShift += 0.002;
    }
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updateShapes();

    for (const shape of shapes) {
      drawMandala(shape);
    }

    time += 1;
    requestAnimationFrame(animate);
  }

  initializeShapes();
  animate();


  // Function to draw the text
  // Ensure canvas resizes dynamically
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initializeShapes(); // Reinitialize shapes to fit new dimensions
  }

  // Function to draw the text
  function drawText() {
    const text = ["Happy", "Holidays"]; // Text to display
    const fontSize = Math.min(canvas.width, canvas.height) / 4; // Dynamic font size
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const letterSpacing = fontSize * 0.1; // Add some space between letters

    ctx.save();
    ctx.font = `bold ${fontSize}px Comic Sans MS`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Draw each letter individually
    let letterIndex = 0; // Unique index for each letter instance
    text.forEach((line, lineIndex) => {
      const yOffset = lineIndex === 0 ? -fontSize * 0.7 : fontSize * 0.7; // Adjust y position for each line
      let xOffset = centerX - (ctx.measureText(line).width / 2); // Start x position

      for (const char of line) {
        // Assign a color for each letter using its unique index
        const color = textColors[letterColorIndices[letterIndex] % textColors.length];
        ctx.fillStyle = color;

        // Draw the letter
        ctx.fillText(char, xOffset, centerY + yOffset);

        // Move xOffset for the next letter
        xOffset += ctx.measureText(char).width + letterSpacing;

        letterIndex++; // Increment the unique index for the next letter instance
      }
    });

    ctx.restore();
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update the blinking color for each letter instance every 30 frames
    blinkTimer++;
    if (blinkTimer % 30 === 0) {
      for (let i = 0; i < letterColorIndices.length; i++) {
        letterColorIndices[i] = (letterColorIndices[i] + 1) % textColors.length; // Cycle through colors
      }
    }

    // Draw background flakes
    updateShapes();
    for (const shape of shapes.slice(0, Math.floor(shapes.length / 2))) {
      drawMandala(shape);
    }

    // Draw the text in the center
    drawText();

    // Draw foreground flakes
    for (const shape of shapes.slice(Math.floor(shapes.length / 2))) {
      drawMandala(shape);
    }

    // Increment animation time
    time += 1;
    requestAnimationFrame(animate);
  }

  // Ensure the canvas resizes dynamically
  window.addEventListener("resize", resizeCanvas);

  // Initialize letterColorIndices for unique blinking
  const text = ["Merry", "Christmas"];
  letterColorIndices = []; // Ensure it's an array
  text.forEach(line => {
    for (let charIndex = 0; charIndex < line.length; charIndex++) {
      letterColorIndices.push(Math.floor(Math.random() * textColors.length)); // Assign a random color index for each letter instance
    }
  });

  // Call initialization and animation
  resizeCanvas(); // Resize canvas to current window dimensions
  animate();


  // Resize canvas dynamically
  window.addEventListener("resize", () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initializeShapes();
  });

  function refreshCanvasOnClick() {
  const canvas = document.getElementById("patternCanvas");
  canvas.addEventListener("click", () => {
    location.reload(); // Reload the page when the canvas is clicked
  });
}
refreshCanvasOnClick()
</script>

</body>
</html>
